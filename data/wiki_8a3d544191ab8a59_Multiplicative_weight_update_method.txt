Title: Multiplicative weight update method
URL: https://en.wikipedia.org/wiki/Multiplicative_weight_update_method
PageID: 52242050
Categories: Category:Algorithms, Category:Machine learning, Category:Randomized algorithms
Source: Wikipedia (CC BY-SA 4.0).

-----
The multiplicative weights update method is an algorithmic technique most commonly used for decision making and prediction, and also widely deployed in game theory and algorithm design. The simplest use case is the problem of prediction from expert advice, in which a decision maker needs to iteratively decide on an expert whose advice to follow. The method assigns initial weights to the experts (usually identical initial weights), and updates these weights multiplicatively and iteratively according to the feedback of how well an expert performed: reducing it in case of poor performance, and increasing it otherwise. [ 1 ] It was discovered repeatedly in very diverse fields such as machine learning ( AdaBoost , Winnow , Hedge), optimization (solving linear programs ), theoretical computer science (devising fast algorithm for LPs and SDPs ), and game theory .
Name
"Multiplicative weights" implies the iterative rule used in algorithms derived from the multiplicative weight update method. [ 2 ] It is given with different names in the different fields where it was discovered or rediscovered.
History and background
The earliest known version of this technique was in an algorithm named " fictitious play " which was proposed in game theory in the early 1950s. Grigoriadis and Khachiyan [ 3 ] applied a randomized variant of "fictitious play" to solve two-player zero-sum games efficiently using the multiplicative weights algorithm. In this case, player allocates higher weight to the actions that had a better outcome and choose his strategy relying on these weights. In machine learning , Littlestone applied the earliest form of the multiplicative weights update rule in his famous winnow algorithm , which is similar to Minsky and Papert's earlier perceptron learning algorithm . Later, he generalized the winnow algorithm to weighted majority algorithm. Freund and Schapire followed his steps and generalized the winnow algorithm in the form of hedge algorithm.
The multiplicative weights algorithm is also widely applied in computational geometry such as Kenneth Clarkson's algorithm for linear programming (LP) with a bounded number of variables in linear time. [ 4 ] [ 5 ] Later, Bronnimann and Goodrich employed analogous methods to find set covers for hypergraphs with small VC dimension . [ 6 ]
In operations research and on-line statistical decision making problem field, the weighted majority algorithm and its more complicated versions have been found independently.
In computer science field, some researchers have previously observed the close relationships between multiplicative update algorithms used in different contexts. Young discovered the similarities between fast LP algorithms and Raghavan's method of pessimistic estimators for derandomization of randomized rounding algorithms; Klivans and Servedio linked boosting algorithms in learning theory to proofs of Yao's XOR Lemma; Garg and Khandekar defined a common framework for convex optimization problems that contains Garg-Konemann and Plotkin-Shmoys-Tardos as subcases. [ 1 ]
The Hedge algorithm is a special case of mirror descent .
General setup
A binary decision needs to be made based on n experts’ opinions to attain an associated payoff. In the first round, all experts’ opinions have the same weight. The decision maker will make the first decision based on the majority of the experts' prediction. Then, in each successive round, the decision maker will repeatedly update the weight of each expert's opinion depending on the correctness of his prior predictions. Real life examples includes predicting if it is rainy tomorrow or if the stock market will go up or go down.
Algorithm analysis
Halving algorithm
Given a sequential game played between an adversary and an aggregator who is advised by N experts, the goal is for the aggregator to make as few mistakes as possible. Assume there is an expert among the N experts who always gives the correct prediction. In the halving algorithm, only the consistent experts are retained. Experts who make mistakes will be dismissed. For every decision, the aggregator decides by taking a majority vote among the remaining experts. Therefore, every time the aggregator makes a mistake, at least half of the remaining experts are dismissed. The aggregator makes at most log 2 ( N ) mistakes. [ 2 ]
Weighted majority algorithm
Source: [ 1 ] [ 7 ]
Unlike halving algorithm which dismisses experts who have made mistakes, weighted majority algorithm discounts their advice. Given the same "expert advice" setup, suppose we have n decisions, and we need to select one decision for each loop. In each loop, every decision incurs a cost. All costs will be revealed after making the choice. The cost is 0 if the expert is correct, and 1 otherwise. this algorithm's goal is to limit its cumulative losses to roughly the same as the best of experts.
The very first algorithm that makes choice based on majority vote every iteration does not work since the majority of the experts can be wrong consistently every time. The weighted majority algorithm corrects above trivial algorithm by keeping a weight of experts instead of fixing the cost at either 1 or 0. [ 1 ] This would make fewer mistakes compared to halving algorithm.
If η = 0 {\displaystyle \eta =0} , the weight of the expert's advice will remain the same. When η {\displaystyle \eta } increases, the weight of the expert's advice will decrease. Note that some researchers fix η = 1 / 2 {\displaystyle \eta =1/2} in weighted majority algorithm.
After T {\displaystyle T} steps, let m i T {\displaystyle m_{i}^{T}} be the number of mistakes of expert i and M T {\displaystyle M^{T}} be the number of mistakes our algorithm has made. Then we have the following bound for every i {\displaystyle i} :
In particular, this holds for i which is the best expert. Since the best expert will have the least m i T {\displaystyle m_{i}^{T}} , it will give the best bound on the number of mistakes made by the algorithm as a whole.
Randomized weighted majority algorithm
This algorithm can be understood as follows: [ 2 ] [ 8 ]
Given the same setup with N experts. Consider the special situation where the proportions of experts predicting positive and negative, counting the weights, are both close to 50%. Then, there might be a tie. Following the weight update rule in weighted majority algorithm, the predictions made by the algorithm would be randomized. The algorithm calculates the probabilities of experts predicting positive or negatives, and then makes a random decision based on the computed fraction: [ further explanation needed ]
predict
where
The number of mistakes made by the randomized weighted majority algorithm is bounded as:
where α β = ln ⁡ ( 1 β ) 1 − β {\displaystyle \alpha _{\beta }={\frac {\ln({\frac {1}{\beta }})}{1-\beta }}} and c β = 1 1 − β {\displaystyle c_{\beta }={\frac {1}{1-\beta }}} .
Note that only the learning algorithm is randomized. The underlying assumption is that the examples and experts' predictions are not random. The only randomness is the randomness where the learner makes his own prediction.
In this randomized algorithm , α β → 1 {\displaystyle \alpha _{\beta }\rightarrow 1} if β → 1 {\displaystyle \beta \rightarrow 1} . Compared to weighted algorithm, this randomness halved the number of mistakes the algorithm is going to make. [ 9 ] However, it is important to note that in some research, people define η = 1 / 2 {\displaystyle \eta =1/2} in weighted majority algorithm and allow 0 ≤ η ≤ 1 {\displaystyle 0\leq \eta \leq 1} in randomized weighted majority algorithm . [ 2 ]
Applications
The multiplicative weights method is usually used to solve a constrained optimization problem. Let each expert be the constraint in the problem, and the events represent the points in the area of interest. The punishment of the expert corresponds to how well its corresponding constraint is satisfied on the point represented by an event. [ 1 ]
Solving zero-sum games approximately (Oracle algorithm)
Source: [ 1 ] [ 9 ]
Suppose we were given the distribution P {\displaystyle P} on experts. Let A {\displaystyle A} = payoff matrix of a finite two-player zero-sum game, with n {\displaystyle n} rows.
When the row player p r {\displaystyle p_{r}} uses plan i {\displaystyle i} and the column player p c {\displaystyle p_{c}} uses plan j {\displaystyle j} , the payoff of player p c {\displaystyle p_{c}} is A ( i , j ) {\displaystyle A\left(i,j\right)} ≔ A i j {\displaystyle A_{ij}} , assuming A ( i , j ) ∈ [ 0 , 1 ] {\displaystyle A\left(i,j\right)\in \left[0,1\right]} .
If player p r {\displaystyle p_{r}} chooses action i {\displaystyle i} from a distribution P {\displaystyle P} over the rows, then the expected result for player p c {\displaystyle p_{c}} selecting action j {\displaystyle j} is A ( P , j ) = E i ∈ P [ A ( i , j ) ] {\displaystyle A\left(P,j\right)=E_{i\in P}\left[A\left(i,j\right)\right]} .
To maximize A ( P , j ) {\displaystyle A\left(P,j\right)} , player p c {\displaystyle p_{c}} should choose plan j {\displaystyle j} . Similarly, the expected payoff for player p l {\displaystyle p_{l}} is A ( i , P ) = E j ∈ P [ A ( i , j ) ] {\displaystyle A\left(i,P\right)=E_{j\in P}\left[A\left(i,j\right)\right]} . Choosing plan i {\displaystyle i} would minimize this payoff. By John Von Neumann's Min-Max Theorem , we obtain:
where P and i changes over the distributions over rows, Q and j changes over the columns.
Then, let λ ∗ {\displaystyle \lambda ^{*}} denote the common value of above quantities, also named as the "value of the game". Let δ > 0 {\displaystyle \delta >0} be an error parameter. To solve the zero-sum game bounded by additive error of δ {\displaystyle \delta } ,
So there is an algorithm solving zero-sum game up to an additive factor of δ using O( log 2 ( n ) / δ 2 {\displaystyle \delta ^{2}} ) calls to ORACLE, with an additional processing time of O(n) per call [ 9 ]
Bailey and Piliouras showed that although the time average behavior of multiplicative weights update converges to Nash equilibria in zero-sum games the day-to-day (last iterate) behavior diverges away from it. [ 10 ]
Machine learning
In machine learning, Littlestone and Warmuth generalized the winnow algorithm to the weighted majority algorithm. [ 11 ] Later, Freund and Schapire generalized it in the form of hedge algorithm. [ 12 ] AdaBoost Algorithm formulated by Yoav Freund and Robert Schapire also employed the Multiplicative Weight Update Method. [ 1 ]
Winnow algorithm
Based on current knowledge in algorithms, the multiplicative weight update method was first used in Littlestone's winnow algorithm. [ 1 ] It is used in machine learning to solve a linear program.
Given m {\displaystyle m} labeled examples ( a 1 , l 1 ) , … , ( a m , l m ) {\displaystyle \left(a_{1},l_{1}\right),{\text{…}},\left(a_{m},l_{m}\right)} where a j ∈ R n {\displaystyle a_{j}\in \mathbb {R} ^{n}} are feature vectors, and l j ∈ { − 1 , 1 } {\displaystyle l_{j}\in \left\{-1,1\right\}\quad } are their labels.
The aim is to find non-negative weights such that for all examples, the sign of the weighted combination of the features matches its labels. That is, require that l j a j x ≥ 0 {\displaystyle l_{j}a_{j}x\geq 0} for all j {\displaystyle j} . Without loss of generality, assume the total weight is 1 so that they form a distribution. Thus, for notational convenience, redefine a j {\displaystyle a_{j}} to be l j a j {\displaystyle l_{j}a_{j}} , the problem reduces to finding a solution to the following LP:
This is general form of LP.
Hedge algorithm
Source: [ 2 ]
The hedge algorithm is similar to the weighted majority algorithm. However, their exponential update rules are different. [ 2 ] It is generally used to solve the problem of binary allocation in which we need to allocate different portion of resources into N different options. The loss with every option is available at the end of every iteration. The goal is to reduce the total loss suffered for a particular allocation. The allocation for the following iteration is then revised, based on the total loss suffered in the current iteration using multiplicative update. [ 13 ]
Assume the learning rate η > 0 {\displaystyle \eta >0} and for t ∈ [ T ] {\displaystyle t\in [T]} , p t {\displaystyle p^{t}} is picked by Hedge. Then for all experts i {\displaystyle i} ,
Initialization : Fix an η > 0 {\displaystyle \eta >0} . For each expert, associate the weight w i 1 {\displaystyle w_{i}^{1}} ≔1 For t=1,2,...,T:
AdaBoost algorithm
This algorithm [ 12 ] maintains a set of weights w t {\displaystyle w^{t}} over the training examples. On every iteration t {\displaystyle t} , a distribution p t {\displaystyle p^{t}} is computed by normalizing these weights. This distribution is fed to the weak learner WeakLearn which generates a hypothesis h t {\displaystyle h_{t}} that (hopefully) has small error with respect to the distribution. Using the new hypothesis h t {\displaystyle h_{t}} , AdaBoost generates the next weight vector w t + 1 {\displaystyle w^{t+1}} . The process repeats. After T such iterations, the final hypothesis h f {\displaystyle h_{f}} is the output. The hypothesis h f {\displaystyle h_{f}} combines the outputs of the T weak hypotheses using a weighted majority vote. [ 12 ]
Solving linear programs approximately
Source: [ 14 ]
Problem
Given a m × n {\displaystyle m\times n} matrix A {\displaystyle A} and b ∈ R n {\displaystyle b\in \mathbb {R} ^{n}} , is there a x {\displaystyle x} such that A x ≥ b {\displaystyle Ax\geq b} ?
Assumption
Using the oracle algorithm in solving zero-sum problem, with an error parameter ϵ > 0 {\displaystyle \epsilon >0} , the output would either be a point x {\displaystyle x} such that A x ≥ b − ϵ {\displaystyle Ax\geq b-\epsilon } or a proof that x {\displaystyle x} does not exist, i.e., there is no solution to this linear system of inequalities.
Solution
Given vector p ∈ Δ n {\displaystyle p\in \Delta _{n}} , solves the following relaxed problem
If there exists a x satisfying (1), then x satisfies (2) for all p ∈ Δ n {\displaystyle p\in \Delta _{n}} . The contrapositive of this statement is also true.
Suppose if oracle returns a feasible solution for a p {\displaystyle p} , the solution x {\displaystyle x} it returns has bounded width max i | ( A x ) i − b i | ≤ 1 {\displaystyle \max _{i}|{(Ax)}_{i}-b_{i}|\leq 1} .
So if there is a solution to (1), then there is an algorithm that its output x satisfies the system (2) up to an additive error of 2 ϵ {\displaystyle 2\epsilon } . The algorithm makes at most ln ⁡ ( m ) ϵ 2 {\displaystyle {\frac {\ln(m)}{\epsilon ^{2}}}} calls to a width-bounded oracle for the problem (2). The contrapositive stands true as well. The multiplicative updates is applied in the algorithm in this case.
Other applications
References
External links
The Game Theory of Life a Quanta Magazine article describing the use of the method to evolutionary biology in a paper by Erick Chastain, Adi Livnat, Christos Papadimitriou , and Umesh Vazirani
