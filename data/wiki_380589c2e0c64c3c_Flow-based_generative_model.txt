Title: Flow-based generative model
URL: https://en.wikipedia.org/wiki/Flow-based_generative_model
PageID: 67064736
Categories: Category:Machine learning, Category:Probabilistic models, Category:Statistical models
Source: Wikipedia (CC BY-SA 4.0). Content may require attribution.

-----
Supervised learning
Unsupervised learning
Semi-supervised learning
Self-supervised learning
Reinforcement learning
Meta-learning
Online learning
Batch learning
Curriculum learning
Rule-based learning
Neuro-symbolic AI
Neuromorphic engineering
Quantum machine learning
Classification
Generative modeling
Regression
Clustering
Dimensionality reduction
Density estimation
Anomaly detection
Data cleaning
AutoML
Association rules
Semantic analysis
Structured prediction
Feature engineering
Feature learning
Learning to rank
Grammar induction
Ontology learning
Multimodal learning
Apprenticeship learning
Decision trees
Ensembles Bagging Boosting Random forest
Bagging
Boosting
Random forest
k -NN
Linear regression
Naive Bayes
Artificial neural networks
Logistic regression
Perceptron
Relevance vector machine (RVM)
Support vector machine (SVM)
BIRCH
CURE
Hierarchical
k -means
Fuzzy
Expectation–maximization (EM)
DBSCAN
OPTICS
Mean shift
Factor analysis
CCA
ICA
LDA
NMF
PCA
PGD
t-SNE
SDL
Graphical models Bayes net Conditional random field Hidden Markov
Bayes net
Conditional random field
Hidden Markov
RANSAC
k -NN
Local outlier factor
Isolation forest
Autoencoder
Deep learning
Feedforward neural network
Recurrent neural network LSTM GRU ESN reservoir computing
LSTM
GRU
ESN
reservoir computing
Boltzmann machine Restricted
Restricted
GAN
Diffusion model
SOM
Convolutional neural network U-Net LeNet AlexNet DeepDream
U-Net
LeNet
AlexNet
DeepDream
Neural field Neural radiance field Physics-informed neural networks
Neural radiance field
Physics-informed neural networks
Transformer Vision
Vision
Mamba
Spiking neural network
Memtransistor
Electrochemical RAM (ECRAM)
Q-learning
Policy gradient
SARSA
Temporal difference (TD)
Multi-agent Self-play
Self-play
Active learning
Crowdsourcing
Human-in-the-loop
Mechanistic interpretability
RLHF
Coefficient of determination
Confusion matrix
Learning curve
ROC curve
Kernel machines
Bias–variance tradeoff
Computational learning theory
Empirical risk minimization
Occam learning
PAC learning
Statistical learning
VC theory
Topological deep learning
AAAI
ECML PKDD
NeurIPS
ICML
ICLR
IJCAI
ML
JMLR
Glossary of artificial intelligence
List of datasets for machine-learning research List of datasets in computer vision and image processing
List of datasets in computer vision and image processing
Outline of machine learning
v
t
e
A flow-based generative model is a generative model used in machine learning that explicitly models a probability distribution by leveraging normalizing flow , which is a statistical method using the change-of-variable law of probabilities to transform a simple distribution into a complex one.
The direct modeling of likelihood provides many advantages. For example, the negative log-likelihood can be directly computed and minimized as the loss function . Additionally, novel samples can be generated by sampling from the initial distribution, and applying the flow transformation.
In contrast, many alternative generative modeling methods such as variational autoencoder (VAE) and generative adversarial network do not explicitly represent the likelihood function.
Method
Let z 0 {\displaystyle z_{0}} be a (possibly multivariate) random variable with distribution p 0 ( z 0 ) {\displaystyle p_{0}(z_{0})} .
For i = 1 , . . . , K {\displaystyle i=1,...,K} , let z i = f i ( z i − 1 ) {\displaystyle z_{i}=f_{i}(z_{i-1})} be a sequence of random variables transformed from z 0 {\displaystyle z_{0}} . The functions f 1 , . . . , f K {\displaystyle f_{1},...,f_{K}} should be invertible, i.e. the inverse function f i − 1 {\displaystyle f_{i}^{-1}} exists. The final output z K {\displaystyle z_{K}} models the target distribution.
The log likelihood of z K {\displaystyle z_{K}} is (see derivation ):
Learning probability distributions by differentiating such log Jacobians originated in the Infomax (maximum likelihood) approach to ICA, which forms a single-layer (K=1) flow-based model. Relatedly, the single layer precursor of conditional generative flows appeared in .
To efficiently compute the log likelihood, the functions f 1 , . . . , f K {\displaystyle f_{1},...,f_{K}} should be easily invertible, and the determinants of their Jacobians should be simple to compute. In practice, the functions f 1 , . . . , f K {\displaystyle f_{1},...,f_{K}} are modeled using deep neural networks , and are trained to minimize the negative log-likelihood of data samples from the target distribution. These architectures are usually designed such that only the forward pass of the neural network is required in both the inverse and the Jacobian determinant calculations. Examples of such architectures include NICE, RealNVP, and Glow.
Derivation of log likelihood
Consider z 1 {\displaystyle z_{1}} and z 0 {\displaystyle z_{0}} . Note that z 0 = f 1 − 1 ( z 1 ) {\displaystyle z_{0}=f_{1}^{-1}(z_{1})} .
By the change of variable formula, the distribution of z 1 {\displaystyle z_{1}} is:
Where det d f 1 − 1 ( z 1 ) d z 1 {\displaystyle \det {\frac {df_{1}^{-1}(z_{1})}{dz_{1}}}} is the determinant of the Jacobian matrix of f 1 − 1 {\displaystyle f_{1}^{-1}} .
By the inverse function theorem :
By the identity det ( A − 1 ) = det ( A ) − 1 {\displaystyle \det(A^{-1})=\det(A)^{-1}} (where A {\displaystyle A} is an invertible matrix ), we have:
The log likelihood is thus:
In general, the above applies to any z i {\displaystyle z_{i}} and z i − 1 {\displaystyle z_{i-1}} . Since log ⁡ p i ( z i ) {\displaystyle \log p_{i}(z_{i})} is equal to log ⁡ p i − 1 ( z i − 1 ) {\displaystyle \log p_{i-1}(z_{i-1})} subtracted by a non-recursive term, we can infer by induction that:
Training method
As is generally done when training a deep learning model, the goal with normalizing flows is to minimize the Kullback–Leibler divergence between the model's likelihood and the target distribution to be estimated. Denoting p θ {\displaystyle p_{\theta }} the model's likelihood and p ∗ {\displaystyle p^{*}} the target distribution to learn, the (forward) KL-divergence is:
The second term on the right-hand side of the equation corresponds to the entropy of the target distribution and is independent of the parameter θ {\displaystyle \theta } we want the model to learn, which only leaves the expectation of the negative log-likelihood to minimize under the target distribution. This intractable term can be approximated with a Monte-Carlo method by importance sampling . Indeed, if we have a dataset { x i } i = 1 N {\displaystyle \{x_{i}\}_{i=1}^{N}} of samples each independently drawn from the target distribution p ∗ ( x ) {\displaystyle p^{*}(x)} , then this term can be estimated as:
Therefore, the learning objective
is replaced by
In other words, minimizing the Kullback–Leibler divergence between the model's likelihood and the target distribution is equivalent to maximizing the model likelihood under observed samples of the target distribution.
A pseudocode for training normalizing flows is as follows:
INPUT. dataset x 1 : n {\displaystyle x_{1:n}} , normalizing flow model f θ ( ⋅ ) , p 0 {\displaystyle f_{\theta }(\cdot ),p_{0}} .
SOLVE. max θ ∑ j ln ⁡ p θ ( x j ) {\displaystyle \max _{\theta }\sum _{j}\ln p_{\theta }(x_{j})} by gradient descent
RETURN. θ ^ {\displaystyle {\hat {\theta }}}
Variants
Planar Flow
The earliest example. Fix some activation function h {\displaystyle h} , and let θ = ( u , w , b ) {\displaystyle \theta =(u,w,b)} with the appropriate dimensions, then x = f θ ( z ) = z + u h ( ⟨ w , z ⟩ + b ) {\displaystyle x=f_{\theta }(z)=z+uh(\langle w,z\rangle +b)} The inverse f θ − 1 {\displaystyle f_{\theta }^{-1}} has no closed-form solution in general.
The Jacobian is | det ( I + h ′ ( ⟨ w , z ⟩ + b ) u w T ) | = | 1 + h ′ ( ⟨ w , z ⟩ + b ) ⟨ u , w ⟩ | {\displaystyle |\det(I+h'(\langle w,z\rangle +b)uw^{T})|=|1+h'(\langle w,z\rangle +b)\langle u,w\rangle |} .
For it to be invertible everywhere, it must be nonzero everywhere. For example, h = tanh {\displaystyle h=\tanh } and ⟨ u , w ⟩ > − 1 {\displaystyle \langle u,w\rangle >-1} satisfies the requirement.
Nonlinear Independent Components Estimation (NICE)
Let x , z ∈ R 2 n {\displaystyle x,z\in \mathbb {R} ^{2n}} be even-dimensional, and split them in the middle. Then the normalizing flow functions are x = [ x 1 x 2 ] = f θ ( z ) = [ z 1 z 2 ] + [ 0 m θ ( z 1 ) ] {\displaystyle x={\begin{bmatrix}x_{1}\\x_{2}\end{bmatrix}}=f_{\theta }(z)={\begin{bmatrix}z_{1}\\z_{2}\end{bmatrix}}+{\begin{bmatrix}0\\m_{\theta }(z_{1})\end{bmatrix}}} where m θ {\displaystyle m_{\theta }} is any neural network with weights θ {\displaystyle \theta } .
f θ − 1 {\displaystyle f_{\theta }^{-1}} is just z 1 = x 1 , z 2 = x 2 − m θ ( x 1 ) {\displaystyle z_{1}=x_{1},z_{2}=x_{2}-m_{\theta }(x_{1})} , and the Jacobian is just 1, that is, the flow is volume-preserving.
When n = 1 {\displaystyle n=1} , this is seen as a curvy shearing along the x 2 {\displaystyle x_{2}} direction.
Real Non-Volume Preserving (Real NVP)
The Real Non-Volume Preserving model generalizes NICE model by: x = [ x 1 x 2 ] = f θ ( z ) = [ z 1 e s θ ( z 1 ) ⊙ z 2 ] + [ 0 m θ ( z 1 ) ] {\displaystyle x={\begin{bmatrix}x_{1}\\x_{2}\end{bmatrix}}=f_{\theta }(z)={\begin{bmatrix}z_{1}\\e^{s_{\theta }(z_{1})}\odot z_{2}\end{bmatrix}}+{\begin{bmatrix}0\\m_{\theta }(z_{1})\end{bmatrix}}}
Its inverse is z 1 = x 1 , z 2 = e − s θ ( x 1 ) ⊙ ( x 2 − m θ ( x 1 ) ) {\displaystyle z_{1}=x_{1},z_{2}=e^{-s_{\theta }(x_{1})}\odot (x_{2}-m_{\theta }(x_{1}))} , and its Jacobian is ∏ i = 1 n e s θ ( z 1 , ) {\displaystyle \prod _{i=1}^{n}e^{s_{\theta }(z_{1,})}} . The NICE model is recovered by setting s θ = 0 {\displaystyle s_{\theta }=0} .
Since the Real NVP map keeps the first and second halves of the vector x {\displaystyle x} separate, it's usually required to add a permutation ( x 1 , x 2 ) ↦ ( x 2 , x 1 ) {\displaystyle (x_{1},x_{2})\mapsto (x_{2},x_{1})} after every Real NVP layer.
Generative Flow (Glow)
In generative flow model, each layer has 3 parts:
channel-wise affine transform y c i j = s c ( x c i j + b c ) {\displaystyle y_{cij}=s_{c}(x_{cij}+b_{c})} with Jacobian ∏ c s c H W {\displaystyle \prod _{c}s_{c}^{HW}} .
invertible 1x1 convolution z c i j = ∑ c ′ K c c ′ y c i j {\displaystyle z_{cij}=\sum _{c'}K_{cc'}y_{cij}} with Jacobian det ( K ) H W {\displaystyle \det(K)^{HW}} . Here K {\displaystyle K} is any invertible matrix.
Real NVP, with Jacobian as described in Real NVP.
The idea of using the invertible 1x1 convolution is to permute all layers in general, instead of merely permuting the first and second half, as in Real NVP.
Masked Autoregressive Flow (MAF)
An autoregressive model of a distribution on R n {\displaystyle \mathbb {R} ^{n}} is defined as the following stochastic process:
x 1 ∼ N ( μ 1 , σ 1 2 ) x 2 ∼ N ( μ 2 ( x 1 ) , σ 2 ( x 1 ) 2 ) ⋯ x n ∼ N ( μ n ( x 1 : n − 1 ) , σ n ( x 1 : n − 1 ) 2 ) {\displaystyle {\begin{aligned}x_{1}\sim &N(\mu _{1},\sigma _{1}^{2})\\x_{2}\sim &N(\mu _{2}(x_{1}),\sigma _{2}(x_{1})^{2})\\&\cdots \\x_{n}\sim &N(\mu _{n}(x_{1:n-1}),\sigma _{n}(x_{1:n-1})^{2})\\\end{aligned}}} where μ i : R i − 1 → R {\displaystyle \mu _{i}:\mathbb {R} ^{i-1}\to \mathbb {R} } and σ i : R i − 1 → ( 0 , ∞ ) {\displaystyle \sigma _{i}:\mathbb {R} ^{i-1}\to (0,\infty )} are fixed functions that define the autoregressive model.
By the reparameterization trick , the autoregressive model is generalized to a normalizing flow: x 1 = μ 1 + σ 1 z 1 x 2 = μ 2 ( x 1 ) + σ 2 ( x 1 ) z 2 ⋯ x n = μ n ( x 1 : n − 1 ) + σ n ( x 1 : n − 1 ) z n {\displaystyle {\begin{aligned}x_{1}=&\mu _{1}+\sigma _{1}z_{1}\\x_{2}=&\mu _{2}(x_{1})+\sigma _{2}(x_{1})z_{2}\\&\cdots \\x_{n}=&\mu _{n}(x_{1:n-1})+\sigma _{n}(x_{1:n-1})z_{n}\\\end{aligned}}} The autoregressive model is recovered by setting z ∼ N ( 0 , I n ) {\displaystyle z\sim N(0,I_{n})} .
The forward mapping is slow (because it's sequential), but the backward mapping is fast (because it's parallel).
The Jacobian matrix is lower-diagonal, so the Jacobian is σ 1 σ 2 ( x 1 ) ⋯ σ n ( x 1 : n − 1 ) {\displaystyle \sigma _{1}\sigma _{2}(x_{1})\cdots \sigma _{n}(x_{1:n-1})} .
Reversing the two maps f θ {\displaystyle f_{\theta }} and f θ − 1 {\displaystyle f_{\theta }^{-1}} of MAF results in Inverse Autoregressive Flow (IAF), which has fast forward mapping and slow backward mapping.
Continuous Normalizing Flow (CNF)
Instead of constructing flow by function composition, another approach is to formulate the flow as a continuous-time dynamic. Let z 0 {\displaystyle z_{0}} be the latent variable with distribution p ( z 0 ) {\displaystyle p(z_{0})} . Map this latent variable to data space with the following flow function:
where f {\displaystyle f} is an arbitrary function and can be modeled with e.g. neural networks.
The inverse function is then naturally:
And the log-likelihood of x {\displaystyle x} can be found as:
Since the trace depends only on the diagonal of the Jacobian ∂ z t f {\displaystyle \partial _{z_{t}}f} , this allows "free-form" Jacobian. Here, "free-form" means that there is no restriction on the Jacobian's form. It is contrasted with previous discrete models of normalizing flow, where the Jacobian is carefully designed to be only upper- or lower-diagonal, so that the Jacobian can be evaluated efficiently.
The trace can be estimated by "Hutchinson's trick":
Given any matrix W ∈ R n × n {\displaystyle W\in \mathbb {R} ^{n\times n}} , and any random u ∈ R n {\displaystyle u\in \mathbb {R} ^{n}} with E [ u u T ] = I {\displaystyle E[uu^{T}]=I} , we have E [ u T W u ] = t r ( W ) {\displaystyle E[u^{T}Wu]=tr(W)} . (Proof: expand the expectation directly.)
Usually, the random vector is sampled from N ( 0 , I ) {\displaystyle N(0,I)} (normal distribution) or { ± n − 1 / 2 } n {\displaystyle \{\pm n^{-1/2}\}^{n}} ( Radamacher distribution ).
When f {\displaystyle f} is implemented as a neural network, neural ODE methods would be needed. Indeed, CNF was first proposed in the same paper that proposed neural ODE.
There are two main deficiencies of CNF, one is that a continuous flow must be a homeomorphism , thus preserve orientation and ambient isotopy (for example, it's impossible to flip a left-hand to a right-hand by continuous deforming of space, and it's impossible to turn a sphere inside out , or undo a knot), and the other is that the learned flow f {\displaystyle f} might be ill-behaved, due to degeneracy (that is, there are an infinite number of possible f {\displaystyle f} that all solve the same problem).
By adding extra dimensions, the CNF gains enough freedom to reverse orientation and go beyond ambient isotopy (just like how one can pick up a polygon from a desk and flip it around in 3-space, or unknot a knot in 4-space), yielding the "augmented neural ODE".
Any homeomorphism of R n {\displaystyle \mathbb {R} ^{n}} can be approximated by a neural ODE operating on R 2 n + 1 {\displaystyle \mathbb {R} ^{2n+1}} , proved by combining Whitney embedding theorem for manifolds and the universal approximation theorem for neural networks.
To regularize the flow f {\displaystyle f} , one can impose regularization losses. The paper proposed the following regularization loss based on optimal transport theory : λ K ∫ 0 T ‖ f ( z t , t ) ‖ 2 d t + λ J ∫ 0 T ‖ ∇ z f ( z t , t ) ‖ F 2 d t {\displaystyle \lambda _{K}\int _{0}^{T}\left\|f(z_{t},t)\right\|^{2}dt+\lambda _{J}\int _{0}^{T}\left\|\nabla _{z}f(z_{t},t)\right\|_{F}^{2}dt} where λ K , λ J > 0 {\displaystyle \lambda _{K},\lambda _{J}>0} are hyperparameters. The first term punishes the model for oscillating the flow field over time, and the second term punishes it for oscillating the flow field over space. Both terms together guide the model into a flow that is smooth (not "bumpy") over space and time.
Flows on manifolds
When a probabilistic flow transforms a distribution on an m {\displaystyle m} -dimensional smooth manifold embedded in R n {\displaystyle \mathbb {R} ^{n}} , where m < n {\displaystyle m<n} , and where the transformation is specified as a function, R n → R n {\displaystyle \mathbb {R} ^{n}\to \mathbb {R} ^{n}} , the scaling factor between the source and transformed PDFs is not given by the naive computation of the determinant of the n -by- n {\displaystyle n{\text{-by-}}n} Jacobian (which is zero), but instead by the determinant(s) of one or more suitably defined m -by- m {\displaystyle m{\text{-by-}}m} matrices. This section is an interpretation of the tutorial in the appendix of Sorrenson et al.(2023), where the more general case of non-isometrically embedded Riemann manifolds is also treated. Here we restrict attention to isometrically embedded manifolds.
As running examples of manifolds with smooth, isometric embedding in R n {\displaystyle \mathbb {R} ^{n}} we shall use:
The unit hypersphere : S n − 1 = { x ∈ R n : x ′ x = 1 } {\displaystyle \mathbb {S} ^{n-1}=\{\mathbf {x} \in \mathbb {R} ^{n}:\mathbf {x} '\mathbf {x} =1\}} , where flows can be used to generalize e.g. Von Mises-Fisher or uniform spherical distributions.
The simplex interior: Δ n − 1 = { p = ( p 1 , … , p n ) ∈ R n : p i > 0 , ∑ i p i = 1 } {\displaystyle \Delta ^{n-1}=\{\mathbf {p} =(p_{1},\dots ,p_{n})\in \mathbb {R} ^{n}:p_{i}>0,\sum _{i}p_{i}=1\}} , where n {\displaystyle n} -way categorical distributions live; and where flows can be used to generalize e.g. Dirichlet , or uniform simplex distributions.
As a first example of a spherical manifold flow transform, consider the normalized linear transform , which radially projects onto the unitsphere the output of an invertible linear transform, parametrized by the n -by- n {\displaystyle n{\text{-by-}}n} invertible matrix M {\displaystyle \mathbf {M} } :
In full Euclidean space, f lin : R n → R n {\displaystyle f_{\text{lin}}:\mathbb {R} ^{n}\to \mathbb {R} ^{n}} is not invertible, but if we restrict the domain and co-domain to the unitsphere, then f lin : S n − 1 → S n − 1 {\displaystyle f_{\text{lin}}:\mathbb {S} ^{n-1}\to \mathbb {S} ^{n-1}} is invertible (more specifically it is a bijection and a homeomorphism and a diffeomorphism ), with inverse f lin ( ⋅ ; M − 1 ) {\displaystyle f_{\text{lin}}(\cdot \,;\mathbf {M} ^{-1})} . The Jacobian of f lin : R n → R n {\displaystyle f_{\text{lin}}:\mathbb {R} ^{n}\to \mathbb {R} ^{n}} , at y = f lin ( x ; M ) {\displaystyle \mathbf {y} =f_{\text{lin}}(\mathbf {x} ;\mathbf {M} )} is ‖ M x ‖ − 1 ( I n − y y ′ ) M {\displaystyle \lVert \mathbf {Mx} \rVert ^{-1}(\mathbf {I} _{n}-\mathbf {yy} ')\mathbf {M} } , which has rank n − 1 {\displaystyle n-1} and determinant of zero; while as explained here , the factor (see subsection below) relating source and transformed densities is: ‖ M x ‖ − n | det ⁡ M | {\displaystyle \lVert \mathbf {Mx} \rVert ^{-n}\left|\operatorname {det} \mathbf {M} \right|} .
Differential volume ratio
For m < n {\displaystyle m<n} , let M ⊂ R n {\displaystyle {\mathcal {M}}\subset \mathbb {R} ^{n}} be an m {\displaystyle m} -dimensional manifold with a smooth, isometric embedding into R n {\displaystyle \mathbb {R} ^{n}} . Let f : R n → R n {\displaystyle f:\mathbb {R} ^{n}\to \mathbb {R} ^{n}} be a smooth flow transform with range restricted to M {\displaystyle {\mathcal {M}}} . Let x ∈ M {\displaystyle \mathbf {x} \in {\mathcal {M}}} be sampled from a distribution with density P X {\displaystyle P_{X}} . Let y = f ( x ) {\displaystyle \mathbf {y} =f(\mathbf {x} )} , with resultant (pushforward) density P Y {\displaystyle P_{Y}} . Let U ⊂ M {\displaystyle U\subset {\mathcal {M}}} be a small, convex region containing x {\displaystyle \mathbf {x} } and let V = f ( U ) {\displaystyle V=f(U)} be its image, which contains y {\displaystyle \mathbf {y} } ; then by conservation of probability mass:
where volume (for very small regions) is given by Lebesgue measure in m {\displaystyle m} -dimensional tangent space . By making the regions infinitessimally small, the factor relating the two densities is the ratio of volumes, which we term the differential volume ratio .
To obtain concrete formulas for volume on the m {\displaystyle m} -dimensional manifold, we construct U {\displaystyle U} by mapping an m {\displaystyle m} -dimensional rectangle in (local) coordinate space to the manifold via a smooth embedding function: R m → R n {\displaystyle \mathbb {R} ^{m}\to \mathbb {R} ^{n}} . At very small scale, the embedding function becomes essentially linear so that U {\displaystyle U} is a parallelotope (multidimensional generalization of a parallelogram). Similarly, the flow transform, f {\displaystyle f} becomes linear, so that the image, V = f ( U ) {\displaystyle V=f(U)} is also a parallelotope. In R m {\displaystyle \mathbb {R} ^{m}} , we can represent an m {\displaystyle m} -dimensional parallelotope with an m -by- m {\displaystyle m{\text{-by-}}m} matrix whose column-vectors are a set of edges (meeting at a common vertex) that span the paralellotope. The volume is given by the absolute value of the determinant of this matrix. If more generally (as is the case here), an m {\displaystyle m} -dimensional paralellotope is embedded in R n {\displaystyle \mathbb {R} ^{n}} , it can be represented with a (tall) n -by- m {\displaystyle n{\text{-by-}}m} matrix, say V {\displaystyle \mathbf {V} } . Denoting the parallelotope as / V / {\displaystyle /\mathbf {V} \!/} , its volume is then given by the square root of the Gram determinant :
In the sections below, we show various ways to use this volume formula to derive the differential volume ratio.
Simplex flow
As a first example, we develop expressions for the differential volume ratio of a simplex flow, q = f ( p ) {\displaystyle \mathbf {q} =f(\mathbf {p} )} , where p , q ∈ M = Δ n − 1 {\displaystyle \mathbf {p} ,\mathbf {q} \in {\mathcal {M}}=\Delta ^{n-1}} . Define the embedding function :
which maps a conveniently chosen, ( n − 1 ) {\displaystyle (n-1)} -dimensional representation, p ~ {\displaystyle {\tilde {\mathbf {p} }}} , to the embedded manifold. The n -by- ( n − 1 ) {\displaystyle n{\text{-by-}}(n-1)} Jacobian is E = [ I n − 1 − 1 ′ ] {\displaystyle \mathbf {E} ={\begin{bmatrix}\mathbf {I} _{n-1}\\-{\boldsymbol {1}}'\end{bmatrix}}} .
To define U {\displaystyle U} , the differential volume element at the transformation input ( p ∈ Δ n − 1 {\displaystyle \mathbf {p} \in \Delta ^{n-1}} ), we start with a rectangle in p ~ {\displaystyle {\tilde {\mathbf {p} }}} -space, having (signed) differential side-lengths, d p 1 , … , d p n − 1 {\displaystyle dp_{1},\dots ,dp_{n-1}} from which we form the square diagonal matrix D {\displaystyle \mathbf {D} } , the columns of which span the rectangle. At very small scale, we get U = e ( D ) = / E D / {\displaystyle U=e(\mathbf {D} )=/\mathbf {ED} \!/} , with:
To understand the geometric interpretation of the factor n {\displaystyle {\sqrt {n}}} , see the example for the 1-simplex in the diagram at right.
The differential volume element at the transformation output ( q ∈ Δ n − 1 {\displaystyle \mathbf {q} \in \Delta ^{n-1}} ), is the parallelotope, V = f ( U ) = / F p E D / {\displaystyle V=f(U)=/\mathbf {F_{p}ED} \!/} , where F p {\displaystyle \mathbf {F_{p}} } is the n -by- n {\displaystyle n{\text{-by-}}n} Jacobian of f {\displaystyle f} at p = e ( p ~ ) {\displaystyle \mathbf {p} =e({\tilde {\mathbf {p} }})} . Its volume is:
so that the factor | det ⁡ D ) | {\displaystyle \left|\operatorname {det} \mathbf {D} )\right|} cancels in the volume ratio, which can now already be numerically evaluated. It can however be rewritten in a sometimes more convenient form by also introducing the representation function , r : p ↦ p ~ {\displaystyle r:\mathbf {p} \mapsto {\tilde {\mathbf {p} }}} , which simply extracts the first ( n − 1 ) {\displaystyle (n-1)} components. The Jacobian is R = [ I n 0 ] {\displaystyle \mathbf {R} ={\begin{bmatrix}\mathbf {I} _{n}&{\boldsymbol {0}}\end{bmatrix}}} . Observe that, since e ∘ r ∘ f = f {\displaystyle e\circ r\circ f=f} , the chain rule for function composition gives: E R F p = F p {\displaystyle \mathbf {ERF_{p}} =\mathbf {F_{p}} } . By plugging this expansion into the above Gram determinant and then refactoring it as a product of determinants of square matrices, we can extract the factor | det ⁡ ( E ′ E ) | = n {\displaystyle {\sqrt {\left|\operatorname {det} (\mathbf {E} '\mathbf {E} )\right|}}={\sqrt {n}}} , which now also cancels in the ratio, which finally simpifies to the determinant of the Jacobian of the "sandwiched" flow transformation, r ∘ f ∘ e {\displaystyle r\circ f\circ e} :
which, if p ∼ P P {\displaystyle \mathbf {p} \sim P_{\mathbf {P} }} , can be used to derive the pushforward density after a change of variables, q = f ( p ) {\displaystyle \mathbf {q} =f(\mathbf {p} )} :
This formula is valid only because the simplex is flat and the Jacobian, E {\displaystyle \mathbf {E} } is constant. The more general case for curved manifolds is discussed below, after we present two concrete examples of simplex flow transforms.
Simplex calibration transform
A calibration transform , f cal : Δ n − 1 → Δ n − 1 {\displaystyle f_{\text{cal}}:\Delta ^{n-1}\to \Delta ^{n-1}} , which is sometimes used in machine learning for post-processing of the (class posterior) outputs of a probabilistic n {\displaystyle n} -class classifier, uses the softmax function to renormalize categorical distributions after scaling and translation of the input distributions in log-probability space. For p , q ∈ Δ n − 1 {\displaystyle \mathbf {p} ,\mathbf {q} \in \Delta ^{n-1}} and with parameters, a ≠ 0 {\displaystyle a\neq 0} and c ∈ R n {\displaystyle \mathbf {c} \in \mathbb {R} ^{n}} the transform can be specified as:
where the log is applied elementwise. After some algebra the differential volume ratio can be expressed as:
This result can also be obtained by factoring the density of the SGB distribution , which is obtained by sending Dirichlet variates through f cal {\displaystyle f_{\text{cal}}} .
While calibration transforms are most often trained as discriminative models , the reinterpretation here as a probabilistic flow allows also the design of generative calibration models based on this transform. When used for calibration, the restriction a > 0 {\displaystyle a>0} can be imposed to prevent direction reversal in log-probability space. With the additional restriction c = 0 {\displaystyle \mathbf {c} ={\boldsymbol {0}}} , this transform (with discriminative training) is known in machine learning as temperature scaling .
Generalized calibration transform
The above calibration transform can be generalized to f gcal : Δ n − 1 → Δ n − 1 {\displaystyle f_{\text{gcal}}:\Delta ^{n-1}\to \Delta ^{n-1}} , with parameters c ∈ R n {\displaystyle \mathbf {c} \in \mathbb {R} ^{n}} and A {\displaystyle \mathbf {A} } n -by- n {\displaystyle n{\text{-by-}}n} invertible:
where the condition that A {\displaystyle \mathbf {A} } has 1 {\displaystyle \mathbf {1} } as an eigenvector ensures invertibility by sidestepping the information loss due to the invariance: softmax ⁡ ( x + α 1 ) = softmax ⁡ ( x ) {\displaystyle \operatorname {softmax} (\mathbf {x} +\alpha \mathbf {1} )=\operatorname {softmax} (\mathbf {x} )} . Note in particular that A = λ I n {\displaystyle \mathbf {A} =\lambda \mathbf {I} _{n}} is the only allowed diagonal parametrization, in which case we recover f cal ( p ; λ − 1 , c ) {\displaystyle f_{\text{cal}}(\mathbf {p} ;\lambda ^{-1},\mathbf {c} )} , while (for n > 2 {\displaystyle n>2} ) generalization is possible with non-diagonal matrices. The inverse is:
The differential volume ratio is:
If f gcal {\displaystyle f_{\text{gcal}}} is to be used as a calibration transform, further constraint could be imposed, for example that A {\displaystyle \mathbf {A} } be positive definite , so that ( A x ) ′ x > 0 {\displaystyle (\mathbf {Ax} )'\mathbf {x} >0} , which avoids direction reversals. (This is one possible generalization of a > 0 {\displaystyle a>0} in the f cal {\displaystyle f_{\text{cal}}} parameter.)
For n = 2 {\displaystyle n=2} , a > 0 {\displaystyle a>0} and A {\displaystyle \mathbf {A} } positive definite, then f cal {\displaystyle f_{\text{cal}}} and f gcal {\displaystyle f_{\text{gcal}}} are equivalent in the sense that in both cases, log ⁡ p 1 p 2 ↦ log ⁡ q 1 q 2 {\displaystyle \log {\frac {p_{1}}{p_{2}}}\mapsto \log {\frac {q_{1}}{q_{2}}}} is a straight line, the (positive) slope and offset of which are functions of the transform parameters. For n > 2 , {\displaystyle n>2,} f gcal {\displaystyle f_{\text{gcal}}} does generalize f cal {\displaystyle f_{\text{cal}}} .
It must however be noted that chaining multiple f gcal {\displaystyle f_{\text{gcal}}} flow transformations does not give a further generalization, because:
In fact, the set of f gcal {\displaystyle f_{\text{gcal}}} transformations form a group under function composition. The set of f cal {\displaystyle f_{\text{cal}}} transformations form a subgroup.
Also see: Dirichlet calibration , which generalizes f gcal {\displaystyle f_{\text{gcal}}} , by not placing any restriction on the matrix, A {\displaystyle \mathbf {A} } , so that invertibility is not guaranteed. While Dirichlet calibration is trained as a discriminative model, f gcal {\displaystyle f_{\text{gcal}}} can also be trained as part of a generative calibration model.
Differential volume ratio for curved manifolds
Consider a flow, y = f ( x ) {\displaystyle \mathbf {y} =f(\mathbf {x} )} on a curved manifold, for example S n − 1 {\displaystyle \mathbb {S} ^{n-1}} which we equip with the embedding function, e {\displaystyle e} that maps a set of ( n − 1 ) {\displaystyle (n-1)} angular spherical coordinates to S n − 1 {\displaystyle \mathbb {S} ^{n-1}} . The Jacobian of e {\displaystyle e} is non-constant and we have to evaluate it at both input ( E x {\displaystyle \mathbf {E_{x}} } ) and output ( E y {\displaystyle \mathbf {E_{y}} } ). The same applies to r {\displaystyle r} , the representation function that recovers spherical coordinates from points on S n − 1 {\displaystyle \mathbb {S} ^{n-1}} , for which we need the Jacobian at the output ( R y {\displaystyle \mathbf {R_{y}} } ). The differential volume ratio now generalizes to:
For geometric insight, consider S 2 {\displaystyle \mathbf {S} ^{2}} , where the spherical coordinates are co-latitude, θ ∈ [ 0 , π ] {\displaystyle \theta \in [0,\pi ]} and longitude, ϕ ∈ [ 0 , 2 π ) {\displaystyle \phi \in [0,2\pi )} . At x = e ( θ , ϕ ) {\displaystyle \mathbf {x} =e(\theta ,\phi )} , we get | det ⁡ ( E x ′ E x ) | = sin ⁡ θ {\displaystyle {\sqrt {\left|\operatorname {det} (\mathbf {E} _{\mathbf {x} }'\mathbf {E_{x}} )\right|}}=\sin \theta } , which gives the radius of the circle at that latitude (compare e.g. polar circle to equator). The differential volume (surface area on the sphere) is: sin ⁡ θ d θ d ϕ {\displaystyle \sin \theta \,d\theta \,d\phi } .
The above derivation for R f {\displaystyle R_{f}} is fragile in the sense that when using fixed functions e , r {\displaystyle e,r} , there may be places where they are not well-defined, for example at the poles of the 2-sphere where longitude is arbitrary. This problem is sidestepped (using standard manifold machinery) by generalizing to local coordinates (charts), where in the vicinities of x , y ∈ M {\displaystyle \mathbf {x} ,\mathbf {y} \in {\mathcal {M}}} , we map  from local m {\displaystyle m} -dimensional coordinates to R n {\displaystyle \mathbb {R} ^{n}} and back using the respective function pairs e x , r x {\displaystyle e_{\mathbf {x} },r_{\mathbf {x} }} and e y , r y {\displaystyle e_{\mathbf {y} },r_{\mathbf {y} }} . We continue to use the same notation for the Jacobians of these functions ( E x , E y , R y {\displaystyle \mathbf {E_{x}} ,\mathbf {E_{y}} ,\mathbf {R_{y}} } ), so that the above formula for R f {\displaystyle R_{f}} remains valid.
We can however, choose our local coordinate system in a way that simplifies the expression for R f {\displaystyle R_{f}} and indeed also its practical implementation. Let π : P → R n {\displaystyle \pi :{\mathcal {P}}\to \mathbb {R} ^{n}} be a smooth idempotent projection ( π ∘ π = π {\displaystyle \pi \circ \pi =\pi } ) from the projectible set , P ⊆ R n {\displaystyle {\mathcal {P}}\subseteq \mathbb {R} ^{n}} , onto the embedded manifold. For example:
The positive orthant of R n {\displaystyle \mathbb {R} ^{n}} is projected onto the simplex as: π ( z ) = ( ∑ i = 1 n z i ) − 1 z {\displaystyle \pi (\mathbf {z} )={\bigl (}\sum _{i=1}^{n}z_{i}{\bigr )}^{-1}\mathbf {z} }
Non-zero vectors in R n {\displaystyle \mathbb {R} ^{n}} are projected onto the unitsphere as: π ( z ) = ( ∑ i = 1 n z i 2 ) − 1 2 z {\displaystyle \pi (\mathbf {z} )={\bigl (}\sum _{i=1}^{n}z_{i}^{2}{\bigr )}^{-{\frac {1}{2}}}\mathbf {z} }
For every x ∈ M {\displaystyle \mathbf {x} \in {\mathcal {M}}} , we require of π {\displaystyle \pi } that its n -by- n {\displaystyle n{\text{-by-}}n} Jacobian, Π x {\displaystyle {\boldsymbol {\Pi _{x}}}} has rank m {\displaystyle m} (the manifold dimension), in which case Π x {\displaystyle {\boldsymbol {\Pi _{x}}}} is an idempotent linear projection onto the local tangent space ( orthogonal for the unitsphere: I n − x x ′ {\displaystyle \mathbf {I} _{n}-\mathbf {xx} '} ; oblique for the simplex: I n − x 1 ′ {\displaystyle \mathbf {I} _{n}-{\boldsymbol {x1}}'} ). The columns of Π x {\displaystyle {\boldsymbol {\Pi _{x}}}} span the m {\displaystyle m} -dimensional tangent space at x {\displaystyle \mathbf {x} } . We use the notation, T x {\displaystyle \mathbf {T_{x}} } for any n -by- m {\displaystyle n{\text{-by-}}m} matrix with orthonormal columns ( T x ′ T x = I m {\displaystyle \mathbf {T} _{\mathbf {x} }'\mathbf {T_{x}} =\mathbf {I} _{m}} ) that span the local tangent space. Also note: Π x T x = T x {\displaystyle {\boldsymbol {\Pi _{x}}}\mathbf {T_{x}} =\mathbf {T_{x}} } . We can now choose our local coordinate embedding function, e x : R m → R n {\displaystyle e_{\mathbf {x} }:\mathbb {R} ^{m}\to \mathbb {R} ^{n}} :
Since the Jacobian is injective (full rank: m {\displaystyle m} ), a local (not necessarily unique) left inverse , say r x ∗ {\displaystyle r_{\mathbf {x} }^{*}} with Jacobian R x ∗ {\displaystyle \mathbf {R} _{\mathbf {x} }^{*}} , exists such that r x ∗ ( e x ( x ~ ) ) = x ~ {\displaystyle r_{\mathbf {x} }^{*}(e_{\mathbf {x} }({\tilde {x}}))={\tilde {x}}} and R x ∗ T x = I m {\displaystyle \mathbf {R} _{\mathbf {x} }^{*}\mathbf {T_{x}} =\mathbf {I} _{m}} . In practice we do not need the left inverse function itself, but we do need its Jacobian, for which the above equation does not give a unique solution. We can however enforce a unique solution for the Jacobian by choosing the left inverse as, r x : R n → R m {\displaystyle r_{\mathbf {x} }:\mathbb {R} ^{n}\to \mathbb {R} ^{m}} :
We can now finally plug E x = T x {\displaystyle \mathbf {E_{x}} =\mathbf {T_{x}} } and R y = T y ′ {\displaystyle \mathbf {R_{y}} =\mathbf {T} _{\mathbf {y} }'} into our previous expression for R f {\displaystyle R_{f}} , the differential volume ratio , which because of the orthonormal Jacobians, simplifies to:
Practical implementation
For learning the parameters of a manifold flow transformation, we need access to the differential volume ratio, R f {\displaystyle R_{f}} , or at least to its gradient w.r.t. the parameters. Moreover, for some inference tasks, we need access to R f {\displaystyle R_{f}} itself. Practical solutions include:
Sorrenson et al.(2023) give a solution for computationally efficient stochastic parameter gradient approximation for log ⁡ R f . {\displaystyle \log R_{f}.}
For some hand-designed flow transforms, R f {\displaystyle R_{f}} can be analytically derived in closed form, for example the above-mentioned simplex calibration transforms. Further examples are given below in the section on simple spherical flows.
On a software platform equipped with linear algebra and automatic differentiation , R f ( x ) = | det ⁡ ( T y ′ F x T x ) | {\displaystyle R_{f}(\mathbf {x} )=\left|\operatorname {det} (\mathbf {T_{y}} '\mathbf {F_{x}T_{x}} )\right|} can be automatically evaluated, given access to only x , f , π {\displaystyle \mathbf {x} ,f,\pi } . But this is expensive for high-dimensional data, with at least O ( n 3 ) {\displaystyle {\mathcal {O}}(n^{3})} computational costs. Even then, the slow automatic solution can be invaluable as a tool for numerically verifying hand-designed closed-form solutions.
Simple spherical flows
In machine learning literature, various complex spherical flows formed by deep neural network architectures may be found. In contrast, this section compiles from statistics literature the details of three very simple spherical flow transforms, with simple closed-form expressions for inverses and differential volume ratios. These flows can be used individually, or chained, to generalize distributions on the unitsphere, S n − 1 {\displaystyle \mathbb {S} ^{n-1}} . All three flows are compositions of an invertible affine transform in R n {\displaystyle \mathbb {R} ^{n}} , followed by radial projection back onto the sphere. The flavours we consider for the affine transform are: pure translation, pure linear and general affine. To make these flows fully functional for learning, inference and sampling, the tasks are:
To derive the inverse transform, with suitable restrictions on the parameters to ensure invertibility.
To derive in simple closed form the differential volume ratio , R f {\displaystyle R_{f}} .
An interesting property of these simple spherical flows is that they don't make use of any non-linearities apart from the radial projection. Even the simplest of them, the normalized translation flow, can be chained to form perhaps surprisingly flexible distributions.
Normalized translation flow
The normalized translation flow, f trans : S n − 1 → S n − 1 {\displaystyle f_{\text{trans}}:\mathbb {S} ^{n-1}\to \mathbb {S} ^{n-1}} , with parameter c ∈ R n {\displaystyle \mathbf {c} \in \mathbb {R} ^{n}} , is given by:
The inverse function may be derived by considering, for ℓ > 0 {\displaystyle \ell >0} : y = ℓ − 1 ( x + c ) {\displaystyle \mathbf {y} =\ell ^{-1}(\mathbf {x} +\mathbf {c} )} and then using x ′ x = 1 {\displaystyle \mathbf {x} '\mathbf {x} =1} to get a quadratic equation to recover ℓ {\displaystyle \ell } , which gives:
from which we see that we need ‖ c ‖ < 1 {\displaystyle \lVert \mathbf {c} \rVert <1} to keep ℓ {\displaystyle \ell } real and positive for all y ∈ S n − 1 {\displaystyle \mathbf {y} \in \mathbb {S} ^{n-1}} . The differential volume ratio is given (without derivation) by Boulerice & Ducharme(1994) as:
This can indeed be verified analytically:
By a laborious manipulation of R f ( x ) = | det ⁡ ( T y ′ F x T x ) | {\displaystyle R_{f}(\mathbf {x} )=\left|\operatorname {det} (\mathbf {T_{y}} '\mathbf {F_{x}T_{x}} )\right|} .
By setting M = I n {\displaystyle \mathbf {M} =\mathbf {I} _{n}} in R aff ( x ; M , c ) {\displaystyle R_{\text{aff}}(\mathbf {x} ;\mathbf {M} ,\mathbf {c} )} , which is given below.
Finally, it is worth noting that f trans {\displaystyle f_{\text{trans}}} and f trans − 1 {\displaystyle f_{\text{trans}}^{-1}} do not have the same functional form.
Normalized linear flow
The normalized linear flow, f lin : S n − 1 → S n − 1 {\displaystyle f_{\text{lin}}:\mathbb {S} ^{n-1}\to \mathbb {S} ^{n-1}} , where parameter M {\displaystyle \mathbf {M} } is an invertible n -by- n {\displaystyle n{\text{-by-}}n} matrix, is given by:
The differential volume ratio is:
This result can be derived indirectly via the Angular central Gaussian distribution (ACG) , which can be obtained via normalized linear transform of either Gaussian, or uniform spherical variates. The first relationship can be used to derive the ACG density by a marginalization integral over the radius; after which the second relationship can be used to factor out the differential volume ratio. For details, see ACG distribution .
Normalized affine flow
The normalized affine flow, f aff : S n − 1 → S n − 1 {\displaystyle f_{\text{aff}}:\mathbb {S} ^{n-1}\to \mathbb {S} ^{n-1}} , with parameters c ∈ R n {\displaystyle \mathbf {c} \in \mathbb {R} ^{n}} and M {\displaystyle \mathbf {M} } , n -by- n {\displaystyle n{\text{-by-}}n} invertible, is given by:
The inverse function, derived in a similar way to the normalized translation inverse is:
where W = ( M M ′ ) − 1 {\displaystyle \mathbf {W} =(\mathbf {MM} ')^{-1}} . The differential volume ratio is:
The final RHS numerator was expanded from det ⁡ ( M + c x ′ ) {\displaystyle \operatorname {det} (\mathbf {M} +\mathbf {cx} ')} by the matrix determinant lemma . Recalling R f ( x ) = | det ⁡ ( T y ′ F x T x ) | {\displaystyle R_{f}(\mathbf {x} )=\left|\operatorname {det} (\mathbf {T} _{\mathbf {y} }'\mathbf {F_{x}T_{x}} )\right|} , the equality between R aff {\displaystyle R_{\text{aff}}} and R lin {\displaystyle R_{\text{lin}}} holds because not only:
but also, by orthogonality of x {\displaystyle \mathbf {x} } to the local tangent space:
where F x lin = ‖ M x + c ‖ − 1 ( I n − y y ′ ) ( M + c x ′ ) {\displaystyle \mathbf {F} _{\mathbf {x} }^{\text{lin}}=\lVert \mathbf {Mx} +\mathbf {c} \rVert ^{-1}(\mathbf {I} _{n}-\mathbf {yy} ')(\mathbf {M+cx} ')} is the Jacobian of f lin {\displaystyle f_{\text{lin}}} differentiated w.r.t. its input, but not also w.r.t. to its parameter.
Downsides
Despite normalizing flows success in estimating high-dimensional densities, some downsides still exist in their designs. First of all, their latent space where input data is projected onto is not a lower-dimensional space and therefore, flow-based models do not allow for compression of data by default and require a lot of computation. However, it is still possible to perform image compression with them.
Flow-based models are also notorious for failing in estimating the likelihood of out-of-distribution samples (i.e.: samples that were not drawn from the same distribution as the training set). Some hypotheses were formulated to explain this phenomenon, among which the typical set hypothesis, estimation issues when training models, or fundamental issues due to the entropy of the data distributions.
One of the most interesting properties of normalizing flows is the invertibility of their learned bijective map. This property is given by constraints in the design of the models (cf.: RealNVP, Glow) which guarantee theoretical invertibility. The integrity of the inverse is important in order to ensure the applicability of the change-of-variable theorem , the computation of the Jacobian of the map as well as sampling with the model. However, in practice this invertibility is violated and the inverse map explodes because of numerical imprecision.
Applications
Flow-based generative models have been applied on a variety of modeling tasks, including:
Audio generation
Image generation
Molecular graph generation
Point-cloud modeling
Video generation
Lossy image compression
Anomaly detection
References
External links
Flow-based Deep Generative Models
Normalizing flow models
