Title: Knowledge graph embedding
URL: https://en.wikipedia.org/wiki/Knowledge_graph_embedding
PageID: 67944487
Categories: Category:Graph algorithms, Category:Information science, Category:Knowledge graphs, Category:Machine learning
Source: Wikipedia (CC BY-SA 4.0).

-----
In representation learning , knowledge graph embedding ( KGE ), also called knowledge representation learning ( KRL ), or multi-relation learning , [ 1 ] is a machine learning task of learning a low-dimensional representation of a knowledge graph 's entities and relations while preserving their semantic meaning. [ 1 ] [ 2 ] [ 3 ] Leveraging their embedded representation, knowledge graphs (KGs) can be used for various applications such as link prediction , triple classification, entity recognition , clustering , and relation extraction . [ 1 ] [ 4 ]
Definition
A knowledge graph G = { E , R , F } {\displaystyle {\mathcal {G}}=\{E,R,F\}} is a collection of entities E {\displaystyle E} , relations R {\displaystyle R} , and facts F {\displaystyle F} . [ 5 ] A fact is a triple ( h , r , t ) ∈ F {\displaystyle (h,r,t)\in F} that denotes a link r ∈ R {\displaystyle r\in R} between the head h ∈ E {\displaystyle h\in E} and the tail t ∈ E {\displaystyle t\in E} of the triple. Another notation that is often used in the literature to represent a triple (or fact) is ⟨ head , relation , tail ⟩ {\displaystyle \langle {\text{head}},{\text{relation}},{\text{tail}}\rangle } . This notation is called the Resource Description Framework (RDF). [ 1 ] [ 5 ] A knowledge graph represents the knowledge related to a specific domain; leveraging this structured representation, it is possible to infer a piece of new knowledge from it after some refinement steps. [ 6 ] However, nowadays, people have to deal with the sparsity of data and the computational inefficiency to use them in a real-world application. [ 3 ] [ 7 ]
The embedding of a knowledge graph is a function that translates each entity and each relation into a vector of a given dimension d {\displaystyle d} , called embedding dimension. [ 7 ] It is even possible to embed the entities and relations with different dimensions. [ 7 ] The embedding vectors can then be used for other tasks.
A knowledge graph embedding is characterized by four aspects: [ 1 ]
Representation space: The low-dimensional space in which the entities and relations are represented. [ 1 ]
Scoring function: A measure of the goodness of a triple embedded representation. [ 1 ]
Encoding models: The modality in which the embedded representation of the entities and relations interact with each other. [ 1 ]
Additional information: Any additional information coming from the knowledge graph that can enrich the embedded representation. [ 1 ] Usually, an ad hoc scoring function is integrated into the general scoring function for each additional information. [ 5 ] [ 1 ] [ 8 ]
Embedding procedure
All algorithms for creating a knowledge graph embedding follow the same approach. [ 7 ] First, the embedding vectors are initialized to random values. [ 7 ] Then, they are iteratively optimized using a training set of triples. In each iteration, a batch of size b {\displaystyle b} triples is sampled from the training set, and a triple from it is sampled and corrupted—i.e., a triple that does not represent a true fact in the knowledge graph. [ 7 ] The corruption of a triple involves substituting the head or the tail (or both) of the triple with another entity that makes the fact false. [ 7 ] The original triple and the corrupted triple are added in the training batch, and then the embeddings are updated, optimizing a scoring function. [ 5 ] [ 7 ] Iteration stops when a stop condition is reached. [ 7 ] Usually, the stop condition depends on the overfitting of the training set. [ 7 ] At the end, the learned embeddings should have extracted semantic meaning from the training triples and should correctly predict unseen true facts in the knowledge graph. [ 5 ]
Pseudocode
The following is the pseudocode for the general embedding procedure. [ 9 ] [ 7 ]
Performance indicators
These indexes are often used to measure the embedding quality of a model. The simplicity of the indexes makes them very suitable for evaluating the performance of an embedding algorithm even on a large scale. [ 10 ] Given Q {\displaystyle {\ce {Q}}} as the set of all ranked predictions of a model, it is possible to define three different performance indexes: Hits@K, MR, and MRR. [ 10 ]
Hits@K
Hits@K or in short, H@K, is a performance index that measures the probability to find the correct prediction in the first top K model predictions. [ 10 ] Usually, it is used k = 10 {\displaystyle k=10} . [ 10 ] Hits@K reflects the accuracy of an embedding model to predict the relation between two given triples correctly. [ 10 ]
Hits@K = | { q ∈ Q : q < k } | | Q | ∈ [ 0 , 1 ] {\displaystyle ={\frac {|\{q\in Q:q<k\}|}{|Q|}}\in [0,1]}
Larger values mean better predictive performances. [ 10 ]
Mean rank (MR)
Mean rank is the average ranking position of the items predicted by the model among all the possible items. [ 10 ]
M R = 1 | Q | ∑ q ∈ Q q {\displaystyle MR={\frac {1}{|Q|}}\sum _{q\in Q}{q}}
The smaller the value, the better the model. [ 10 ]
Mean reciprocal rank (MRR)
Mean reciprocal rank measures the number of triples predicted correctly. [ 10 ] If the first predicted triple is correct, then 1 is added, if the second is correct 1 2 {\displaystyle {\frac {1}{2}}} is summed, and so on. [ 10 ]
Mean reciprocal rank is generally used to quantify the effect of search algorithms. [ 10 ]
M R R = 1 | Q | ∑ q ∈ Q 1 q ∈ [ 0 , 1 ] {\displaystyle MRR={\frac {1}{|Q|}}\sum _{q\in Q}{\frac {1}{q}}\in [0,1]}
The larger the index, the better the model. [ 10 ]
Applications
Machine learning tasks
Knowledge graph completion (KGC) is a collection of techniques to infer knowledge from an embedded knowledge graph representation. [ 11 ] In particular, this technique completes a triple inferring the missing entity or relation. [ 11 ] The corresponding sub-tasks are named link or entity prediction (i.e., guessing an entity from the embedding given the other entity of the triple and the relation), and relation prediction (i.e., forecasting the most plausible relation that connects two entities). [ 11 ]
Triple Classification is a binary classification problem. [ 1 ] Given a triple, the trained model evaluates the plausibility of the triple using the embedding to determine if a triple is true or false. [ 11 ] The decision is made with the model score function and a given threshold. [ 11 ] Clustering is another application that leverages the embedded representation of a sparse knowledge graph to condense the representation of similar semantic entities close in a 2D space. [ 4 ]
Real world applications
The use of knowledge graph embedding is increasingly pervasive in many applications. In the case of recommender systems , the use of knowledge graph embedding can overcome the limitations of the usual reinforcement learning , [ 12 ] [ 13 ] as well as limitations of the conventional collaborative filtering method. [ 14 ] Training this kind of recommender system requires a huge amount of information from the users; however, knowledge graph techniques can address this issue by using a graph already constructed over a prior knowledge of the item correlation and using the embedding to infer from it the recommendation. [ 12 ] Drug repurposing is the use of an already approved drug, but for a therapeutic purpose different from the one for which it was initially designed. [ 15 ] It is possible to use the task of link prediction to infer a new connection between an already existing drug and a disease by using a biomedical knowledge graph built leveraging the availability of massive literature and biomedical databases. [ 15 ] Knowledge graph embedding can also be used in the domain of social politics. [ 4 ]
Models
Given a collection of triples (or facts) F = { ⟨ head , relation , tail ⟩ } {\displaystyle {\mathcal {F}}=\{\langle {\text{head}},{\text{relation}},{\text{tail}}\rangle \}} , the knowledge graph embedding model produces, for each entity and relation present in the knowledge graph a continuous vector representation. [ 7 ] ( h , r , t ) {\displaystyle (h,r,t)} is the corresponding embedding of a triple with h , t ∈ I R d {\displaystyle h,t\in {\rm {I\!R}}^{d}} and r ∈ I R k {\displaystyle r\in {\rm {I\!R}}^{k}} , where d {\displaystyle d} is the embedding dimension for the entities, and k {\displaystyle k} for the relations. [ 7 ] The score function of a given model is denoted by f r ( h , t ) {\displaystyle {\mathcal {f}}_{r}(h,t)} and measures the distance of the embedding of the head from the embedding of tail given the embedding of the relation. In other words, it quantifies the plausibility of the embedded representation of a given fact. [ 5 ]
Rossi et al. propose a taxonomy of the embedding models and identifies three main families of models: tensor decomposition models, geometric models, and deep learning models. [ 5 ]
Tensor decomposition model
The tensor decomposition is a family of knowledge graph embedding models that use a multi-dimensional matrix to represent a knowledge graph, [ 1 ] [ 5 ] [ 18 ] that is partially knowable due to gaps of the graph describing a particular domain thoroughly. [ 5 ] In particular, these models use a third-order (3D) tensor , which is then factorized into low-dimensional vectors that are the embeddings. [ 5 ] [ 18 ] A third-order tensor is suitable for representing a knowledge graph because it records only the existence or absence of a relation between entities, [ 18 ] and so is simple, and there is no need to know a priori the network structure, [ 16 ] making this class of embedding models light, and easy to train even if they suffer from high-dimensionality and sparsity of data. [ 5 ] [ 18 ]
Bilinear models
This family of models uses a linear equation to embed the connection between the entities through a relation. [ 1 ] In particular, the embedded representation of the relations is a bidimensional matrix. [ 5 ] These models, during the embedding procedure, only use the single facts to compute the embedded representation and ignore the other associations to the same entity or relation. [ 19 ]
DistMult [ 20 ] : Since the embedding matrix of the relation is a diagonal matrix, [ 5 ] the scoring function can not distinguish asymmetric facts. [ 5 ] [ 19 ]
ComplEx [ 21 ] : As DistMult uses a diagonal matrix to represent the relations embedding but adds a representation in the complex vector space and the hermitian product , it can distinguish symmetric and asymmetric facts. [ 5 ] [ 18 ] This approach is scalable to a large knowledge graph in terms of time and space cost. [ 21 ]
ANALOGY [ 22 ] : This model encodes in the embedding the analogical structure of the knowledge graph to simulate inductive reasoning. [ 22 ] [ 5 ] [ 1 ] Using a differentiable objective function, ANALOGY has good theoretical generality and computational scalability. [ 22 ] It is proven that the embedding produced by ANALOGY fully recovers the embedding of DistMult, ComplEx, and HolE. [ 22 ]
SimplE [ 23 ] : This model is the improvement of canonical polyadic decomposition (CP), in which an embedding vector for the relation and two independent embedding vectors for each entity are learned, depending on whether it is a head or a tail in the knowledge graph fact. [ 23 ] SimplE resolves the problem of independent learning of the two entity embeddings using an inverse relation and average the CP score of ( h , r , t ) {\displaystyle (h,r,t)} and ( t , r − 1 , h ) {\displaystyle (t,r^{-1},h)} . [ 7 ] [ 18 ] In this way, SimplE collects the relation between entities while they appear in the role of subject or object inside a fact, and it is able to embed asymmetric relations. [ 5 ]
Non-bilinear models
HolE: [ 24 ] HolE uses circular correlation to create an embedded representation of the knowledge graph, [ 24 ] which can be seen as a compression of the matrix product, but is more computationally efficient and scalable while keeping the capabilities to express asymmetric relation since the circular correlation is not commutative. [ 19 ] HolE links holographic and complex embeddings since, if used together with Fourier , can be seen as a special case of ComplEx. [ 1 ]
TuckER: [ 25 ] TuckER sees the knowledge graph as a tensor that could be decomposed using the Tucker decomposition in a collection of vectors—i.e., the embeddings of entities and relations—with a shared core. [ 25 ] [ 5 ] The weights of the core tensor are learned together with the embeddings and represent the level of interaction of the entries. [ 26 ] Each entity and relation has its own embedding dimension, and the size of the core tensor is determined by the shape of the entities and relations that interact. [ 5 ] The embedding of the subject and object of a fact are summed in the same way, making TuckER fully expressive, and other embedding models such as RESCAL, DistMult, ComplEx, and SimplE can be expressed as a special formulation of TuckER. [ 25 ]
MEI: [ 27 ] MEI introduces the multi-partition embedding interaction technique with the block term tensor format, which is a generalization of CP decomposition and Tucker decomposition. It divides the embedding vector into multiple partitions and learns the local interaction patterns from data instead of using fixed special patterns as in ComplEx or SimplE models. This enables MEI to achieve optimal efficiency—expressiveness trade-off, not just being fully expressive. [ 27 ] Previous models such as TuckER, RESCAL, DistMult, ComplEx, and SimplE are suboptimal restricted special cases of MEI.
MEIM: [ 28 ] MEIM goes beyond the block term tensor format to introduce the independent core tensor for ensemble boosting effects and the soft orthogonality for max-rank relational mapping, in addition to multi-partition embedding interaction. MEIM generalizes several previous models such as MEI and its subsumed models, RotaE, and QuatE. [ 28 ] MEIM improves expressiveness while still being highly efficient in practice, helping it achieve good results using fairly small model sizes.
Geometric models
The geometric space defined by this family of models encodes the relation as a geometric transformation between the head and tail of a fact. [ 5 ] For this reason, to compute the embedding of the tail, it is necessary to apply a transformation τ {\displaystyle \tau } to the head embedding, and a distance function δ {\displaystyle \delta } is used to measure the goodness of the embedding or to score the reliability of a fact. [ 5 ]
f r ( h , t ) = δ ( τ ( h , r ) , t ) {\displaystyle {\mathcal {f}}_{r}(h,t)=\delta (\tau (h,r),t)}
Geometric models are similar to the tensor decomposition model, but the main difference between the two is that they have to preserve the applicability of the transformation τ {\displaystyle \tau } in the geometric space in which it is defined. [ 5 ]
Pure translational models
This class of models is inspired by the idea of translation invariance introduced in word2vec . [ 7 ] A pure translational model relies on the fact that the embedding vector of the entities are close to each other after applying a proper relational translation in the geometric space in which they are defined. [ 19 ] In other words, given a fact, the embedding of the head plus the embedding of the relation should equal the embedding of the tail. [ 5 ] The closeness of the entities embedding is given by some distance measure and quantifies the reliability of a fact. [ 18 ]
TransE [ 9 ] : Uses a scoring function that forces the embeddings to satisfy a simple vector sum equation in each fact in which they appear: h + r = t {\displaystyle h+r=t} . [ 7 ] The embedding will be exact if each entity and relation appears in only one fact, and so in practice is poor at representing one-to-many , many-to-one , and asymmetric relations. [ 5 ] [ 7 ]
TransH [ 29 ] : A modification of TransE for representing types of relations, by using a hyperplane as a geometric space. [ 29 ] In TransH, the relation embedding is on a different hyperplane depending on the entities it interacts with. [ 7 ] So, to compute, for example, the score function of a fact, the embedded representation of the head and tail need to be projected using a relational projection matrix on the correct hyperplane of the relation. [ 1 ] [ 7 ]
TransR [ 30 ] : A modification of TransH that uses different spaces embedding entities versus relations, [ 1 ] [ 19 ] thus separating the semantic spaces of entities and relations. [ 7 ] TransR also uses a relational projection matrix to translate the embedding of the entities to the relation space. [ 7 ]
TransD : [ 31 ] In TransR, the head and the tail of a given fact could belong to two different types of entities. For example, in the fact ( Obama , president of , USA ) {\displaystyle ({\text{Obama}},{\text{president of}},{\text{USA}})} , Obama is a person and USA is a country. [ 31 ] [ 7 ] Matrix multiplication is an expensive procedure in TransR to compute the projection. [ 7 ] [ 31 ] In this context, TransD uses two vectors for each entity-relation pair to compute a dynamic mapping that substitutes the projection matrix while reducing the dimensional complexity. [ 1 ] [ 7 ] [ 31 ] The first vector is used to represent the semantic meaning of the entities and relations, the second to compute the mapping matrix. [ 31 ]
TransA: [ 32 ] All the translational models define a score function in their representation space, but they oversimplify this metric loss. [ 32 ] Since the vector representation of the entities and relations is not perfect, a pure translation of h + r {\displaystyle h+r} could be distant from t {\displaystyle t} , and a spherical equipotential Euclidean distance makes it hard to distinguish which is the closest entity. [ 32 ] TransA, instead, introduces an adaptive Mahalanobis distance to weights the embedding dimensions, together with elliptical surfaces to remove the ambiguity. [ 1 ] [ 7 ] [ 32 ]
Translational models with additional embeddings
It is possible to associate additional information to each element in the knowledge graph and their common representation facts. [ 1 ] Each entity and relation can be enriched with text descriptions, weights, constraints, and others in order to improve the overall description of the domain with a knowledge graph. [ 1 ] During the embedding of the knowledge graph, this information can be used to learn specialized embeddings for these characteristics together with the usual embedded representation of entities and relations, with the cost of learning a more significant number of vectors. [ 5 ]
STransE: [ 33 ] This model is the result of the combination of TransE and of the structure embedding [ 33 ] in such a way it is able to better represent the one-to-many, many-to-one, and many-to-many relations. [ 5 ] To do so, the model involves two additional independent matrix W r h {\displaystyle W_{r}^{h}} and W r t {\displaystyle W_{r}^{t}} for each embedded relation r {\displaystyle r} in the KG. [ 33 ] Each additional matrix is used based on the fact the specific relation interact with the head or the tail of the fact. [ 33 ] In other words, given a fact ( h , r , t ) {\displaystyle (h,r,t)} , before applying the vector translation, the head h {\displaystyle h} is multiplied by W r h {\displaystyle W_{r}^{h}} and the tail is multiplied by W r t {\displaystyle W_{r}^{t}} . [ 7 ]
CrossE : [ 34 ] Crossover interactions can be used for related information selection, and could be very useful for the embedding procedure. [ 34 ] Crossover interactions provide two distinct contributions in the information selection: interactions from relations to entities and interactions from entities to relations. [ 34 ] This means that a relation, e.g.'president_of'  automatically selects the types of entities that are connecting the subject to the object of a fact. [ 34 ] In a similar way, the entity of a fact inderectly determine which is inference path that has to be choose to predict the object of a related triple. [ 34 ] CrossE, to do so, learns an additional interaction matrix C {\displaystyle C} , uses the element-wise product to compute the interaction between h {\displaystyle h} and r {\displaystyle r} . [ 5 ] [ 34 ] Even if, CrossE, does not rely on a neural network architecture, it is shown that this methodology can be encoded in such architecture. [ 1 ]
Roto-translational models
This family of models, in addition or in substitution of a translation they employ a rotation-like transformation. [ 5 ]
TorusE: [ 35 ] The regularization term of TransE makes the entity embedding to build a spheric space, and consequently loses the translation properties of the geometric space. [ 35 ] To address this problem, TorusE leverages the use of a compact Lie group that in this specific case is n-dimensional torus space, and avoid the use of regularization. [ 1 ] [ 35 ] TorusE defines the distance functions to substitute the L1 and L2 norm of TransE. [ 5 ]
RotatE: [ 36 ] RotatE is inspired by the Euler's identity and involves the use of Hadamard product to represent a relation r {\displaystyle r} as a rotation from the head h {\displaystyle h} to the tail t {\displaystyle t} in the complex space. [ 36 ] For each element of the triple, the complex part of the embedding describes a counterclockwise rotation respect to an axis, that can be describe with the Euler's identity, whereas the modulus of the relation vector is 1. [ 36 ] It is shown that the model is capable of embedding symmetric, asymmetric, inversion, and composition relations from the knowledge graph. [ 36 ]
Deep learning models
This group of embedding models uses deep neural network to learn patterns from the knowledge graph that are the input data. [ 5 ] These models have the generality to distinguish the type of entity and relation, temporal information, path information, underlay structured information, [ 19 ] and resolve the limitations of distance-based and semantic-matching-based models in representing all the features of a knowledge graph. [ 1 ] The use of deep learning for knowledge graph embedding has shown good predictive performance even if they are more expensive in the training phase, data-hungry, and often required a pre-trained embedding representation of knowledge graph coming from a different embedding model. [ 1 ] [ 5 ]
Convolutional neural networks
This family of models, instead of using fully connected layers, employs one or more convolutional layers that convolve the input data applying a low-dimensional filter capable of embedding complex structures with few parameters by learning nonlinear features. [ 1 ] [ 5 ] [ 19 ]
ConvE: [ 37 ] ConvE is an embedding model that represents a good tradeoff expressiveness of deep learning models and computational expensiveness, [ 18 ] in fact it is shown that it used 8x less parameters, when compared to DistMult. [ 37 ] ConvE uses a one-dimensional d {\displaystyle d} -sized embedding to represent the entities and relations of a knowledge graph. [ 5 ] [ 37 ] To compute the score function of a triple, ConvE apply a simple procedure: first concatenes and merge the embeddings of the head of the triple and the relation in a single data [ h ; r ] {\displaystyle {\ce {[h;{\mathcal {r}}]}}} , then this matrix is used as input for the 2D convolutional layer. [ 5 ] [ 18 ] The result is then passed through a dense layer that apply a linear transformation parameterized by the matrix W {\displaystyle {\mathcal {W}}} and at the end, with the inner product is linked to the tail triple. [ 5 ] [ 19 ] ConvE is also particularly efficient in the evaluation procedure: using a 1-N scoring, the model matches, given a head and a relation, all the tails at the same time, saving a lot of evaluation time when compared to the 1-1 evaluation program of the other models. [ 19 ]
ConvR: [ 38 ] ConvR is an adaptive convolutional network aimed to deeply represent all the possible interactions between the entities and the relations. [ 38 ] For this task, ConvR, computes convolutional filter for each relation, and, when required, applies these filters to the entity of interest to extract convoluted features. [ 38 ] The procedure to compute the score of triple is the same as ConvE. [ 5 ]
ConvKB: [ 39 ] ConvKB, to compute score function of a given triple ( h , r , t ) {\displaystyle (h,r,t)} , it produces an input [ h ; r ; t ] {\displaystyle {\ce {[h;{\mathcal {r}};t]}}} of dimension d × 3 {\displaystyle d\times 3} without reshaping and passes it to series of convolutional filter of size 1 × 3 {\displaystyle 1\times 3} . [ 39 ] This result feeds a dense layer with only one neuron that produces the final score. [ 39 ] The single final neuron makes this architecture as a binary classifier in which the fact could be true or false. [ 5 ] A difference with ConvE is that the dimensionality of the entities is not changed. [ 18 ]
Capsule neural networks
This family of models uses capsule neural networks to create a more stable representation that is able to recognize a feature in the input without losing spatial information. [ 5 ] The network is composed of convolutional layers, but they are organized in capsules, and the overall result of a capsule is sent to a higher-capsule decided by a dynamic process routine. [ 5 ]
CapsE: [ 40 ] CapsE implements a capsule network to model a fact ( h , r , t ) {\displaystyle (h,r,t)} . [ 40 ] As in ConvKB, each triple element is concatenated to build a matrix [ h ; r ; t ] {\displaystyle {\ce {[h;{\mathcal {r}};t]}}} and is used to feed to a convolutional layer to extract the convolutional features. [ 5 ] [ 40 ] These features are then redirected to a capsule to produce a continuous vector, more the vector is long, more the fact is true. [ 40 ]
Recurrent neural networks
This class of models leverages the use of recurrent neural network . [ 5 ] The advantage of this architecture is to memorize a sequence of fact, rather than just elaborate single events. [ 41 ]
RSN: [ 41 ] During the embedding procedure is commonly assumed that, similar entities has similar relations. [ 41 ] In practice, this type of information is not leveraged, because the embedding is computed just on the undergoing fact rather than a history of facts. [ 41 ] Recurrent skipping networks (RSN) uses a recurrent neural network to learn relational path using a random walk sampling. [ 5 ] [ 41 ]
Model performance
The machine learning task for knowledge graph embedding that is more often used to evaluate the embedding accuracy of the models is the link prediction. [ 1 ] [ 3 ] [ 5 ] [ 6 ] [ 7 ] [ 19 ] Rossi et al. [ 5 ] produced an extensive benchmark of the models, but also other surveys produces similar results. [ 3 ] [ 7 ] [ 19 ] [ 26 ] The benchmark involves five datasets FB15k, [ 9 ] WN18, [ 9 ] FB15k-237, [ 42 ] WN18RR, [ 37 ] and YAGO3-10. [ 43 ] More recently, it has been discussed that these datasets are far away from real-world applications, and other datasets should be integrated as a standard benchmark. [ 44 ]
Libraries
KGE on GitHub
MEI-KGE on GitHub
Pykg2vec on GitHub
DGL-KE on GitHub
PyKEEN on GitHub
TorchKGE on GitHub
AmpliGraph on GitHub
OpenKE on GitHub
scikit-kge on GitHub
Fast-TransX on GitHub
MEIM-KGE on GitHub
DICEE on GitHub
See also
Knowledge graph
Embedding
Machine learning
Knowledge base
Knowledge extraction
Statistical relational learning
Representation learning
Graph embedding
References
External links
Open Graph Benchmark - Stanford
WordNet - Princeton
